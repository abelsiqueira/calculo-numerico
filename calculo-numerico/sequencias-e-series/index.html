<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/calculo-numerico/libs/katex/katex.min.css"> <link rel=stylesheet  href="/calculo-numerico/libs/highlight/github.min.css"> <link href="/calculo-numerico/css/bootstrap.min.css" rel=stylesheet  crossorigin=anonymous > <link href="https://fonts.googleapis.com/css2?family=Cinzel&family=Lato&family=Montserrat&display=swap" rel=stylesheet > <link rel=icon  href="/calculo-numerico/assets/favicon.png"> <link rel=stylesheet  href="/calculo-numerico/css/code-katex.css"> <link rel=stylesheet  href="/calculo-numerico/css/custom.css"> <link rel=stylesheet  href="/calculo-numerico/css/dark-mode.css"> <title>Aproximações de Números e Funções por Sequências e Séries</title> <header> <nav class="navbar navbar-expand-lg"> <div class=container-fluid > <a class="navbar-brand text-end" href="/calculo-numerico/">Abel S.<br>Siqueira</a> <button class=navbar-toggler  type=button  data-bs-toggle=collapse  data-bs-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav ms-auto mb-2 mb-lg-0"> <li class=nav-item ><a class=nav-link  href="/calculo-numerico/">Home</a> <li class=nav-item ><a class=nav-link  href="/calculo-numerico/julia/">Julia</a> <li class=nav-item ><a class=nav-link  href="/calculo-numerico/research/">Research</a> <li class=nav-item ><a class=nav-link  href="/calculo-numerico/ufpr/">UFPR</a> </ul> <div class="dark-switch form-check form-switch"> <input type=checkbox  class=form-check-input  id=darkSwitch  /> <label class=custom-control-label  for=darkSwitch >Dark Mode</label> </div> <script src="/calculo-numerico/libs/dark-mode-switch.min.js"></script> </div> </div> </nav> </header> <div class=container-fluid > <div class="container main-text"> <div class=franklin-content ><h1 id="aproximações_de_números_e_funções_por_sequências_e_séries"><a href="#aproximações_de_números_e_funções_por_sequências_e_séries" class=header-anchor >Aproximações de Números e Funções por Sequências e Séries</a></h1> <p>Os objetivos desta lição são</p> <ul> <li><p>Identificar como lidar com sequências e séries em programação;</p> <li><p>Entender que elementos anteriores da sequência são substituídos;</p> <li><p>Tentar gastar o mínimo de elementos e variáveis &#40;mantendo a clareza&#41;;</p> <li><p>Tomar cuidado com overflow e underflow;</p> <li><p>Relembrar/treinar a programação.</p> </ul> <h2 id="sequências"><a href="#sequências" class=header-anchor >Sequências</a></h2> <p>Uma sequência em matemática é um conjunto de valores ordenados:</p> \[ (a_1, a_2, a_3, \dots, a_n, \dots) \] <p>O índice \(1\) usado no primeiro elemento é arbitrário, e serve para normalizar essa ordem. Em alguns casos é mais interessante começar com o índice \(0\).</p> <p>Matematicamente, costumamos estar interessados na convergência dessa sequência. No entanto, podemos utilizar uma sequência por outros motivos. Computacionalmente, estamos interessados em <strong>como obter os elementos de uma sequência, quando necessário.</strong></p> <p>É importante ressaltar aqui a importância da frase <strong>quando necessário</strong>, pois como veremos a seguir, não é do nosso interesse calcular todos esses valores ao mesmo tempo, e quase sempre também não seria possível.</p> <h3 id=exemplo_1 ><a href="#exemplo_1" class=header-anchor >Exemplo 1</a></h3> <p>Dado um objeto com aceleração constante de \(10 m/s^2\) saindo do repouso, queremos calcular sua posição nos instantes \(t = 0, 0.1, 0.2, 0.3, \dots\). Note que temos uma sequência \(t_n = (n-1)/10\), e queremos uma sequência \(x_n\) das posições.</p> <p>Neste caso, porém, as leis de movimento nos dizem que</p> \[ x(t) = x_0 + v_0 t + \frac{1}{2}at^2, \] <p>que em nosso caso se reduz a</p> \[ x(t) = 5t^2. \] <p>Em outras palavras, a sequência \(x_n\) pode ser calculada diretamente dado \(t_n\), e \(t_n\) também tem uma fórmula geral dado \(n\),</p> \[ x_n = 5\bigg(\frac{n-1}{10}\bigg)^2 = \frac{(n-1)^2}{20}. \] <p>Desse modo, não é necessário guardar nada em especial, pois \(x_n\) pode ser calculado diretamente a partir de \(n\).</p> <h3 id=exemplo_2 ><a href="#exemplo_2" class=header-anchor >Exemplo 2</a></h3> <p>Dado um número \(x \in \mathbb{N}, x > 1\), queremos calcular a sequência de Collatz desse número. Em particular, queremos calcular qual o primeiro elemento que é \(1\) &#40;se houver&#41;.</p> <p>Aqui é importante ressaltar a conjectura de Collatz: Dado um número \(a_1 \in \mathbb{N}\), e a fórmula recursiva</p> \[ a_{n+1} = \left\{\begin{array}{ll} a_n/2, & \text{se } a_n \text{ é par}; \\ 3a_n + 1, & \text{se } a_n \text{ é impar}, \end{array}\right. \] <p>sempre existe um elemento desta sequência tal que \(a_n = 1\). A partir desse ponto a sequência perde a importância. Por exemplo, a sequência de Collatz de 3 é</p> \[ 3 \rightarrow 10 \rightarrow 5 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 \rightarrow 4 \rightarrow 2 \rightarrow 1 \cdots \] <p>Nessa sequência, é necessário saber quem é o ponto atual, e é impossível saber um elemento arbitrário da sequência em casos gerais. Dessa maneira é preciso calcular elemento a elemento.</p> <p>Lembre-se que para verificar a paridade de um número, utilizamos <code>&#37;</code>.</p> <pre><code class=language-julia >15 &#37; 2</code></pre><pre><code class=plaintext >1</code></pre>
<pre><code class=language-julia >14 &#37; 2</code></pre><pre><code class=plaintext >0</code></pre>
<pre><code class=language-julia >15 &#37; 2 &#61;&#61; 0 # É par ?</code></pre><pre><code class=plaintext >false</code></pre>
<pre><code class=language-julia >14 &#37; 2 &#61;&#61; 0 # É par ?</code></pre><pre><code class=plaintext >true</code></pre>
<p>Lembre-se também que para dividir um número e mantê-lo inteiro, usamos <code>div</code>.</p>
<pre><code class=language-julia >div&#40;15, 2&#41;</code></pre><pre><code class=plaintext >7</code></pre>
<pre><code class=language-julia >div&#40;14, 2&#41;</code></pre><pre><code class=plaintext >7</code></pre>
<pre><code class=language-julia >14/2 # 7.0 e 7 são o mesmo valor, mas são diferentes em computação</code></pre><pre><code class=plaintext >7.0</code></pre>
<p>Um <strong>erro</strong> comum de alunos inexperientes nesse caso é <strong>tentar numerar todos os elementos</strong>.</p>
<pre><code class=language-julia >a1 &#61; 3
if a1 &#37; 2 &#61;&#61; 0
    a2 &#61; div&#40;a1, 2&#41;
else
    a2 &#61; 3 * a1 &#43; 1
end</code></pre><pre><code class=plaintext >10</code></pre>
<pre><code class=language-julia >if a2 &#37; 2 &#61;&#61; 0
    a3 &#61; div&#40;a2, 2&#41;
else
    a3 &#61; 3 * a2 &#43; 1
end</code></pre><pre><code class=plaintext >5</code></pre>
<p>Essa estratégia logo fica inviável. No entanto, note que precisamos apenas do valor atual da sequência, de maneira que podemos usar apenas uma mesma variável <code>a</code> que irá guardar sempre o valor mais atual.</p>
<pre><code class=language-julia >a &#61; 300

if a &#37; 2 &#61;&#61; 0
    a &#61; div&#40;a, 2&#41;
else
    a &#61; 3 * a &#43; 1
end
a

if a &#37; 2 &#61;&#61; 0
    a &#61; div&#40;a, 2&#41;
else
    a &#61; 3 * a &#43; 1
end
a

if a &#37; 2 &#61;&#61; 0
    a &#61; div&#40;a, 2&#41;
else
    a &#61; 3 * a &#43; 1
end
a</code></pre><pre><code class=plaintext >226</code></pre>
<p>Rodando mais de uma vez esse bloco, fazemos uma nova iteração da sequência. Para deixar mais claro, vamos guardar também uma variável <code>n</code> que diz qual o índice da sequência.</p>
<pre><code class=language-julia >a &#61; 3
n &#61; 1

if a &#37; 2 &#61;&#61; 0
    a &#61; div&#40;a, 2&#41;
else
    a &#61; 3 * a &#43; 1
end
n &#61; n &#43; 1
println&#40;&quot;a &#61; &#36;a, n &#61; &#36;n&quot;&#41;

if a &#37; 2 &#61;&#61; 0
    a &#61; div&#40;a, 2&#41;
else
    a &#61; 3 * a &#43; 1
end
n &#61; n &#43; 1
println&#40;&quot;a &#61; &#36;a, n &#61; &#36;n&quot;&#41;

if a &#37; 2 &#61;&#61; 0
    a &#61; div&#40;a, 2&#41;
else
    a &#61; 3 * a &#43; 1
end
n &#61; n &#43; 1
println&#40;&quot;a &#61; &#36;a, n &#61; &#36;n&quot;&#41;</code></pre><pre><code class=plaintext >a = 10, n = 2
a = 5, n = 3
a = 16, n = 4
</code></pre>
<p>Note que <code>n</code> também pode ser usado para responder a pergunta original: quando <code>a</code> for 1, teremos o <code>n</code> marcando o índice correspondente.</p>
<p>Isso nos leva a um conceito importante. Note que sequências contém infinitos elementos. No entanto, computacionalmente, não podemos fazer contas infinitas. Isso constitui um <strong>loop infinito</strong>. Códigos com loops infinitos são considerados <strong>&quot;errados&quot;</strong> &#40;no sentido de não fazerem o que se espera&#41;, então devemos evitá-los. Portanto, o fato de percebermos que para resolver o problema, devemos fazer a conta do Bloco 2 até que <code>n</code> seja 1 é de extrema importância, pois isso evitará um loop infinito &#40;dado que a conjectura de Collatz esteja correta&#41;.</p>
<p>Com isso, podemos definir um termo formal para este conjunto de código com um objetivo específico:</p>
<p><strong>Def. &#40;Algoritmo&#41;:</strong> Um algoritmo é uma coleção de instruções para realizar alguma tarefa específica. Segundo Knuth &#40;The Art of Computer Programming, v.1&#41;, ele deve satisfazer as seguintes condições, parafraseadas aqui:</p>
<ul>
<li><p><strong>Finitude:</strong> O algoritmo deve acabar em tempo finito;</p>

<li><p><strong>Bem definido:</strong> As intruções devem ser claras e sem ambiguidade;</p>

<li><p><strong>Entrada:</strong> O algoritmo tem zero ou mais entradas, que são valores determinados antes do algoritmo começar. Essas entradas são especificados a partir de conjuntos de objetos;</p>

<li><p><strong>Saída:</strong> O algoritmo tem uma ou mais saídas, que são quantidades relacionadas com as entradas;</p>

<li><p><strong>Eficácia/Computabilidade:</strong> As operações feitas no algoritmo devem ser suficientemente básicas para que a princípio possam ser executadas por uma pessoa num espaço finito e tempo finito com papel e caneta.</p>

</ul>
<p>Podemos fazer uma prévia do nosso algoritmo:</p>
<ol>
<li><p>Entrada: \(x\)</p>

<li><p>Inicialização: \(a \leftarrow x, n \leftarrow 1\).</p>

<li><p>Enquanto \(a > 1\)</p>
<ol>
<li><p>Se \(a\) é par,  faça \(a \leftarrow a/2\)</p>

<li><p>Caso contrário,  faça \(a \leftarrow 3a + 1\).</p>

<li><p>Incremente \(n\).</p>

</ol>

<li><p>Saída: \(n\).</p>

</ol>
<p>Nosso algoritmo para encontrar o primeiro elemento está quase feito. A entrada, saída, e todos os passos estão claros. Todos os passos são triviamente feitos com papel e caneta. No entanto, temos alguns pequenos problemas:</p>
<ul>
<li><p><strong>E se a conjectura for falsa?</strong></p>

</ul>
<p>Se a conjectura é verdadeira, o algoritmo para quando encontra <code>1</code>, que pela conjectura, existe. Mas se não existe, pode ser que tenhamos um loop infinito. Dessa maneira, iremos colocar uma <strong>condição de parada</strong> para a falha do algoritmo. Não existe uma regra para a condição de parada. Deve-se tomar cuidado, no entanto, para não excluir a possibilidade do algoritmo funcionar em muitos casos. Uma condição de parada possível neste caso é que <code>n</code> seja muito grande. Se, por exemplo, fizermos 1 milhão de iterações e não encontrarmos <code>a_n &#61; 1</code>, então talvez ele não exista. Note que essa condição exclui algumas soluções de aparecerem, por exemplo</p>
\[ a_1 = 2^{1.000.000}. \]
<p>É fácil ver que \(a_n = 2^{1.000.001 - n}\), de modo que para <code>n &#61; 1.000.001</code> teremos \(a_n = 1\).</p>
<p>Muitas vezes a condições de parada de falha é um limitante físico para deixar o algoritmo tratável. É muito fácil escolher um número <code>x</code> tal que nosso algoritmo leve horas para convergir. Não é do nosso interesse esperar tanto para um algoritmo recreativo. Poderíamos colocar uma condição de tempo então. Qual condição escolher é um assunto complicado, que depende de muitos outros fatores além da disciplina. Em especial, a teoria matemática arredor do problema deve ser considerada. Imagine que a conjectura de Collatz é falsa, e que <code>x</code> é um valor finito tal que a sequência gerada com <code>a_1 &#61; x</code> nunca decresça à <code>1</code>. <em>Como é possível verificar que <code>x</code> é um contra-exemplo para a conjectura?</em></p>
<ul>
<li><p><strong>O maior inteiro.</strong></p>

</ul>
<p>O computador é uma máquina física, com limitações impostas para que seja possível fazer contas determinísticas. Dessa maneira, ele segue regras para definir números inteiros e &quot;reais&quot; &#40;as aspas serão explicadas depois&#41;, e essas regras limitam o maior inteiro que pode ser representado por um tipo específico de dado. Mais importante, esse valor é independente da linguagem. A saber, o tipo de inteiro básico do Julia é o <code>Int64</code>, de 64 bits, e cujo maior valor é \(2^{63}-1 \approx 10^{18}\). Coisas estranhas acontecem se fizermos qualquer conta com esse valor, de modo que é imperativo não ultrapassá-lo. Vamos colocar uma nova condição de parada no nosso código: se \(a > 10^{17}\), também paramos.</p>
<ol>
<li><p>Entrada: \(x \in \mathbb{N}\)</p>

<li><p>Inicialização: \(a \leftarrow x, n \leftarrow 1, a\_\text{bound} = 10^17, n\_\text{bound} = 10^6\)</p>

<li><p>Se \(a \leq 0\)  faça \(n \leftarrow 0\)  termine o algoritmo</p>

<li><p>Enquanto \(a > 1\)</p>
<ol>
<li><p>Se \(a\) é par,  faça \(a \leftarrow a/2\)</p>

<li><p>Caso contrário,  faça \(a \leftarrow 3a + 1\).</p>

<li><p>Incremente \(n\).</p>

<li><p>Se \(a > a\_\text{bound}\)  faça \(n \leftarrow -1\) e termine o algoritmo</p>

<li><p>Se \(n > n\_\text{bound}\)  faça \(n \leftarrow -2\) e termine o algoritmo</p>

</ol>

<li><p>Saída: \(n\)  Se \(n > 0\), então \(a_n = 1\): Saída bem sucedida,  Se \(n = 0\), então \(x \leq 0\): Saída de erro na entrada,  Se \(n = -1\), então \(a\) ficou muito grande: Saída de valor muito grande,  Se \(n = -2\), então \(n\) ficou muito grande: Saída de muitas iterações.</p>

</ol>
<p>Keyword argument</p>
<pre><code class=language-julia >function collatz&#40;a::Int; a_bound &#61; 10^17, n_bound &#61; 1_000_000&#41; # O mesmo que começar com x e atribuir x à a.
    n &#61; 1
    if a &lt;&#61; 0
        return 0
    end
    while a &gt; 1
        print&#40;&quot;&#36;a &quot;&#41;
        if a &#37; 2 &#61;&#61; 0
            a &#61; div&#40;a, 2&#41;
        else
            a &#61; 3a &#43; 1
        end
        n &#43;&#61; 1
        if a &gt; a_bound
            return -1
        elseif n &gt; n_bound
            return -2
        end
    end
    return n
end</code></pre><pre><code class=plaintext >collatz (generic function with 1 method)</code></pre>
<pre><code class=language-julia >collatz&#40;151&#41;</code></pre><pre><code class=plaintext >151 454 227 682 341 1024 512 256 128 64 32 16 8 4 2 
16</code></pre>
<pre><code class=language-julia >collatz&#40;2^30, n_bound&#61;10&#41;</code></pre><pre><code class=plaintext >1073741824 536870912 268435456 134217728 67108864 33554432 16777216 8388608 4194304 2097152 
-2</code></pre>
<pre><code class=language-julia >collatz&#40;1&#41;</code></pre><pre><code class=plaintext >1</code></pre>
<pre><code class=language-julia >collatz&#40;10^17&#43;2&#41;</code></pre><pre><code class=plaintext >100000000000000002 50000000000000001 
-1</code></pre>
<h2 id=fibonacci ><a href="#fibonacci" class=header-anchor >Fibonacci</a></h2>
<p>Vamos continuar nosso exemplo com mais uma sequência interessante, a de Fibonacci:</p>
\[ F_1 = F_2 = 1 \qquad F_{n+1} = F_n + F_{n-1}. \]
<p>A sequência de Fibonacci envolve dois termos, e cresce infinitamente. Existem vários motivos para se trabalhar com a série de Fibonacci, mas vamos utilizá-la recreativamente. Vamos criar um simples algoritmo para calcular o n-ésimo termo da série de Fibonacci. Assuma, por enquanto, que todos os termos serão bem representados por inteiros de 64 bits.</p>
<p>Entrada: \(n\) inteiro</p>
<ol>
<li><p>Se \(n \leq 0\)  retorne \(0\)</p>

<li><p>Se \(n = 1\) ou \(n = 2\)  retorne \(1\)</p>

<li><p>Inicialização: \(F_1 \leftarrow 1, F_2 \leftarrow 1, k \leftarrow 2\)</p>

<li><p>Enquanto \(k < n\)</p>
<ol>
<li><p>\(F_{\text{novo}} \leftarrow F_1 + F_2\) - Isso calcula o valor novo</p>

<li><p>\(F_1 \leftarrow F_2\) - O valor \(F_2\) passa a ser o mais antigo dos dois</p>

<li><p>\(F_2 \leftarrow F_{\text{novo}}\) - O valor \(F_{\text{novo}}\) passa a ser o anterior</p>

<li><p>Incremente \(k\)</p>

</ol>

<li><p>Retorne \(F_2\).  Saída: 0 se a entrada estava incorreta, \(F_n\) caso contrário.</p>

</ol>
<pre><code class=language-julia >function fibon&#40;n::Int&#41;
    if n ≤ 0 #\le
        return 0
    elseif n &#61;&#61; 1 || n &#61;&#61; 2
        return 1
    end
    F1, F2, k &#61; 1, 1, 2
    while k &lt; n
        F3 &#61; F1 &#43; F2
        F1, F2 &#61; F2, F3
        #F1, F2 &#61; F2, F1 &#43; F2
        k &#43;&#61; 1
    end
    return F2
end

for n &#61; 1:20
    println&#40;&quot;F_&#36;n &#61; &#36;&#40;fibon&#40;n&#41;&#41;&quot;&#41;
end</code></pre><pre><code class=plaintext >F_1 = 1
F_2 = 1
F_3 = 2
F_4 = 3
F_5 = 5
F_6 = 8
F_7 = 13
F_8 = 21
F_9 = 34
F_10 = 55
F_11 = 89
F_12 = 144
F_13 = 233
F_14 = 377
F_15 = 610
F_16 = 987
F_17 = 1597
F_18 = 2584
F_19 = 4181
F_20 = 6765
</code></pre>
<p>É bastante simple calcular um elemento da sequência de Fibonacci, e é interessante que podemos explorar outra maneira de fazer isso.</p>
<h3 id="recursão"><a href="#recursão" class=header-anchor >Recursão</a></h3>
<pre><code class=language-julia >function fat_por_recursao&#40;n::Int&#41;
    if n &lt; 0
        error&#40;&quot;BLAH&quot;&#41;
    end
    if n &#61;&#61; 0
        return 1
    end
    return n * fat_por_recursao&#40;n - 1&#41;
end

fat_por_recursao&#40;5&#41;</code></pre><pre><code class=plaintext >120</code></pre>
<pre><code class=language-julia >fat_por_recursao&#40;21&#41;</code></pre><pre><code class=plaintext >-4249290049419214848</code></pre>
<p>operador ternário</p>
<p>PROP ? Resultado se SIM : Resultado se NAO</p>
<pre><code class=language-julia >5 &gt; 0 ? &quot;ok&quot; : &quot;oops&quot;</code></pre><pre><code class=plaintext >"ok"</code></pre>
<pre><code class=language-julia >fat_uma_linha&#40;n::Int&#41; &#61; n &#61;&#61; 0 ? 1 : n * fat_uma_linha&#40;n - 1&#41;</code></pre><pre><code class=plaintext >fat_uma_linha (generic function with 1 method)</code></pre>
<pre><code class=language-julia >fat_uma_linha&#40;5&#41;</code></pre><pre><code class=plaintext >120</code></pre>
<p>Recursão é uma das partes mais importantes no desenvolvimento de códigos. Muitas estratégias computacionais e matemáticas envolvem o chamado &quot;dividir e conquistar&quot; ou &quot;reduzir para um caso conhecido&quot;. Em particular, demonstrações por indução finita fazem uma coisa parecida, onde você supõe saber resolver para um caso e consegue resolver um caso de nível superior reduzindo-o ao caso conhecido.</p>
<p>Computacionalmente, podemos pensar em recursão como a divisão de um problema em outros, cada um destes menor que o primeiro. Para cada problema menor, repetimos o processo. Como não podemos ter um loop infinito, é necessário terminar essa redução de alguma maneira. Essa maneira envolve, simplesmente, saber resolver alguns casos de problema menor &#40;que garantam a convergência&#41;.</p>
<p>No caso de Fibonacci, o cálculo do n-ésimo termo é feito calculando os termos n-1 e n-2. Os casos n-1 e n-2 são, de fato, menores. Além disso, repetindo este processo chegaremos a dois casos: n &#61; 1 ou n &#61; 2. Desse modo, temos</p>
<ul>
<li><p>casos pequenos que conseguimos resolver trivialmente;</p>

<li><p>uma maneira de reduzir um problema em outros menores;</p>

<li><p>garantia matemática que essa redução leva aos problemas menores que sabemos resolver.</p>

</ul>
<p>Abaixo temos um pseudo-código.</p>
<p>Rotina \(\text{FIBO}(n)\)</p>
<p>Entrada: \(n\)</p>
<ol>
<li><p>Se \(n = 1\) ou \(n = 2\)  retorne \(1\)</p>

<li><p>Senão,  retorna \(\text{FIBO}(n-1) + \text{FIBO}(n-2)\)</p>

</ol>
<pre><code class=language-julia >function FIBO&#40;n&#41;
    if n &lt;&#61; 2
        return min&#40;1, max&#40;n, 0&#41;&#41; # Pequeno truque
    else
        return FIBO&#40;n-1&#41; &#43; FIBO&#40;n-2&#41;
    end
end

FIBO&#40;10&#41;

for n &#61; 1:20
    println&#40;&quot;F_&#36;n &#61; &#36;&#40;FIBO&#40;n&#41;&#41;&quot;&#41;
end</code></pre><pre><code class=plaintext >F_1 = 1
F_2 = 1
F_3 = 2
F_4 = 3
F_5 = 5
F_6 = 8
F_7 = 13
F_8 = 21
F_9 = 34
F_10 = 55
F_11 = 89
F_12 = 144
F_13 = 233
F_14 = 377
F_15 = 610
F_16 = 987
F_17 = 1597
F_18 = 2584
F_19 = 4181
F_20 = 6765
</code></pre>
<p>Muitas vezes, o código de recursão será mais curto. Em particular, em Julia &#40;e C&#41; temos o chamado <strong>operador ternário</strong>, que nos permite fazer a pergunta <code>if ... else ... end</code> em uma única linha. Desse modo, temos uma implementação curtíssima de Fibonacci:</p>
<pre><code class=language-julia >F&#40;n&#41; &#61; n &lt;&#61; 2 ? min&#40;1, max&#40;n, 0&#41;&#41; : F&#40;n-1&#41; &#43; F&#40;n-2&#41;

for n &#61; 1:20
    println&#40;&quot;F_&#36;n &#61; &#36;&#40;F&#40;n&#41;&#41;&quot;&#41;
end</code></pre><pre><code class=plaintext >F_1 = 1
F_2 = 1
F_3 = 2
F_4 = 3
F_5 = 5
F_6 = 8
F_7 = 13
F_8 = 21
F_9 = 34
F_10 = 55
F_11 = 89
F_12 = 144
F_13 = 233
F_14 = 377
F_15 = 610
F_16 = 987
F_17 = 1597
F_18 = 2584
F_19 = 4181
F_20 = 6765
</code></pre>
<p>No entanto, é importante ter cuidado ao utilizar recursão. O custo computacional fica escondido nas chamadas de função, e às vezes podemos deixar um código muito mais complicado do que deveria. No caso de Fibonacci, por exemplo, ao calcular <code>F&#40;n&#41;</code>, pedimos o cálculo de <code>F&#40;n-1&#41;</code> e <code>F&#40;n-2&#41;</code>, mas o cálculo de <code>F&#40;n-1&#41;</code> irá pedir o cálculo de <code>F&#40;n-2&#41;</code> e <code>F&#40;n-3&#41;</code>, ou seja, <code>F&#40;n-2&#41;</code> será calculado duas vezes&#33;</p>
<pre><code class=language-julia >function FIBO_comprint&#40;n&#41;
    println&#40;&quot;Chamada: F&#36;n&quot;&#41;
    if n &lt;&#61; 2
        return min&#40;1, max&#40;n, 0&#41;&#41; # Pequeno truque
    else
        return FIBO_comprint&#40;n-1&#41; &#43; FIBO_comprint&#40;n-2&#41;
    end
end

FIBO_comprint&#40;5&#41;</code></pre><pre><code class=plaintext >Chamada: F5
Chamada: F4
Chamada: F3
Chamada: F2
Chamada: F1
Chamada: F2
Chamada: F3
Chamada: F2
Chamada: F1
5</code></pre>
<p>Em outras palavras, Fibonacci com recursão acaba sendo muito mais caro que Fibonacci usando <code>for</code> ou <code>while</code>. Tome cuidado com essas armadilhas.</p>
<p><strong>Leitura adicional:</strong> Existe um conceito chamada &quot;Avaliação preguiçosa&quot;, que consiste na avaliação dos valores somente quando são necessários. Em Julia, o pacote <code>Lazy.jl</code> implementa esse conceito. Se a avaliação de <code>F&#40;n&#41;</code> for feita de maneira preguiçosa, não haverá o custo adicional do cálculo de \(F_n\) repetidos.</p>
<h2 id=mais_fibonacci ><a href="#mais_fibonacci" class=header-anchor >Mais Fibonacci</a></h2>
<p>Vamos voltar nossa atenção ao problema inicial de Fibonacci: calcular o n-ésimo termo. Nossas últimas discussões foram todas no sentido de como calcular os elementos de Fibonacci termo a termo ou recursivamente. Porém, matematicamente, o n-ésimo termo de Fibonacci é bem definido&#33;</p>
\[ F_n = \frac{\phi^n - \psi^n}{\sqrt{5}}, \]
<p>onde </p>
\[\phi = \frac{1 + \sqrt{5}}{2}\]
<p>e </p>
\[\psi = \frac{1 - \sqrt{5}}{2} = 1 - \phi. \]
<p>Isso quer dizer que podemos calcular Fibonacci com uma fórmula direta.</p>
<pre><code class=language-julia >phi &#61; &#40;1 &#43; sqrt&#40;5&#41;&#41;/2
psi &#61; 1 - phi
for n &#61; 1:20
    Fn &#61; round&#40;Int, &#40;phi^n - psi^n&#41;/sqrt&#40;5&#41;&#41;
    println&#40;&quot;F_&#36;n &#61; &#36;Fn&quot;&#41;
end</code></pre><pre><code class=plaintext >F_1 = 1
F_2 = 1
F_3 = 2
F_4 = 3
F_5 = 5
F_6 = 8
F_7 = 13
F_8 = 21
F_9 = 34
F_10 = 55
F_11 = 89
F_12 = 144
F_13 = 233
F_14 = 377
F_15 = 610
F_16 = 987
F_17 = 1597
F_18 = 2584
F_19 = 4181
F_20 = 6765
</code></pre>
<p>Perceba que o problema aqui agora é outro. Os valores não estão mais &quot;corretos&quot;. Na verdade, quase todos contém um pequeno <strong>erro</strong>.</p>
<p>Quão pequeno?</p>
<pre><code class=language-julia >phi &#61; &#40;1 &#43; sqrt&#40;5&#41;&#41;/2
psi &#61; 1 - phi
F1 &#61; F2 &#61; 1
Fnovo &#61; 1
for n &#61; 3:93
    Fn &#61; &#40;phi^n - psi^n&#41;/sqrt&#40;5&#41;
    Fnovo &#61; F1 &#43; F2
    F2 &#61; F1
    F1 &#61; Fnovo
    println&#40;&quot;F_&#36;n &#61; &#36;Fnovo, Diferença F_&#36;n &#61; &#36;&#40;Fn - Fnovo&#41;&quot;&#41;
end</code></pre><pre><code class=plaintext >F_3 = 2, Diferença F_3 = 0.0
F_4 = 3, Diferença F_4 = 0.0
F_5 = 5, Diferença F_5 = 8.881784197001252e-16
F_6 = 8, Diferença F_6 = 1.7763568394002505e-15
F_7 = 13, Diferença F_7 = 1.7763568394002505e-15
F_8 = 21, Diferença F_8 = 3.552713678800501e-15
F_9 = 34, Diferença F_9 = 7.105427357601002e-15
F_10 = 55, Diferença F_10 = 1.4210854715202004e-14
F_11 = 89, Diferença F_11 = 2.842170943040401e-14
F_12 = 144, Diferença F_12 = 5.684341886080802e-14
F_13 = 233, Diferença F_13 = 5.684341886080802e-14
F_14 = 377, Diferença F_14 = 1.7053025658242404e-13
F_15 = 610, Diferença F_15 = 3.410605131648481e-13
F_16 = 987, Diferença F_16 = 4.547473508864641e-13
F_17 = 1597, Diferença F_17 = 9.094947017729282e-13
F_18 = 2584, Diferença F_18 = 1.8189894035458565e-12
F_19 = 4181, Diferença F_19 = 2.7284841053187847e-12
F_20 = 6765, Diferença F_20 = 4.547473508864641e-12
F_21 = 10946, Diferença F_21 = 7.275957614183426e-12
F_22 = 17711, Diferença F_22 = 1.0913936421275139e-11
F_23 = 28657, Diferença F_23 = 2.1827872842550278e-11
F_24 = 46368, Diferença F_24 = 3.637978807091713e-11
F_25 = 75025, Diferença F_25 = 5.820766091346741e-11
F_26 = 121393, Diferença F_26 = 8.731149137020111e-11
F_27 = 196418, Diferença F_27 = 1.7462298274040222e-10
F_28 = 317811, Diferença F_28 = 2.9103830456733704e-10
F_29 = 514229, Diferença F_29 = 4.656612873077393e-10
F_30 = 832040, Diferença F_30 = 8.149072527885437e-10
F_31 = 1346269, Diferença F_31 = 1.1641532182693481e-9
F_32 = 2178309, Diferença F_32 = 2.3283064365386963e-9
F_33 = 3524578, Diferença F_33 = 3.725290298461914e-9
F_34 = 5702887, Diferença F_34 = 6.51925802230835e-9
F_35 = 9227465, Diferença F_35 = 1.1175870895385742e-8
F_36 = 14930352, Diferença F_36 = 1.862645149230957e-8
F_37 = 24157817, Diferença F_37 = 2.9802322387695312e-8
F_38 = 39088169, Diferença F_38 = 4.470348358154297e-8
F_39 = 63245986, Diferença F_39 = 6.705522537231445e-8
F_40 = 102334155, Diferença F_40 = 1.341104507446289e-7
F_41 = 165580141, Diferença F_41 = 2.086162567138672e-7
F_42 = 267914296, Diferença F_42 = 3.5762786865234375e-7
F_43 = 433494437, Diferença F_43 = 5.960464477539062e-7
F_44 = 701408733, Diferença F_44 = 1.0728836059570312e-6
F_45 = 1134903170, Diferença F_45 = 1.6689300537109375e-6
F_46 = 1836311903, Diferença F_46 = 2.6226043701171875e-6
F_47 = 2971215073, Diferença F_47 = 4.76837158203125e-6
F_48 = 4807526976, Diferença F_48 = 7.62939453125e-6
F_49 = 7778742049, Diferença F_49 = 1.33514404296875e-5
F_50 = 12586269025, Diferença F_50 = 1.9073486328125e-5
F_51 = 20365011074, Diferença F_51 = 3.4332275390625e-5
F_52 = 32951280099, Diferença F_52 = 5.340576171875e-5
F_53 = 53316291173, Diferença F_53 = 9.1552734375e-5
F_54 = 86267571272, Diferença F_54 = 0.000152587890625
F_55 = 139583862445, Diferença F_55 = 0.000274658203125
F_56 = 225851433717, Diferença F_56 = 0.00042724609375
F_57 = 365435296162, Diferença F_57 = 0.00067138671875
F_58 = 591286729879, Diferença F_58 = 0.0010986328125
F_59 = 956722026041, Diferença F_59 = 0.0018310546875
F_60 = 1548008755920, Diferença F_60 = 0.0029296875
F_61 = 2504730781961, Diferença F_61 = 0.0048828125
F_62 = 4052739537881, Diferença F_62 = 0.00830078125
F_63 = 6557470319842, Diferença F_63 = 0.013671875
F_64 = 10610209857723, Diferença F_64 = 0.021484375
F_65 = 17167680177565, Diferença F_65 = 0.037109375
F_66 = 27777890035288, Diferença F_66 = 0.0625
F_67 = 44945570212853, Diferença F_67 = 0.09375
F_68 = 72723460248141, Diferença F_68 = 0.171875
F_69 = 117669030460994, Diferença F_69 = 0.28125
F_70 = 190392490709135, Diferença F_70 = 0.4375
F_71 = 308061521170129, Diferença F_71 = 0.6875
F_72 = 498454011879264, Diferença F_72 = 1.1875
F_73 = 806515533049393, Diferença F_73 = 2.0
F_74 = 1304969544928657, Diferença F_74 = 3.0
F_75 = 2111485077978050, Diferença F_75 = 5.25
F_76 = 3416454622906707, Diferença F_76 = 8.5
F_77 = 5527939700884757, Diferença F_77 = 14.0
F_78 = 8944394323791464, Diferença F_78 = 24.0
F_79 = 14472334024676221, Diferença F_79 = 40.0
F_80 = 23416728348467685, Diferença F_80 = 64.0
F_81 = 37889062373143906, Diferença F_81 = 104.0
F_82 = 61305790721611591, Diferença F_82 = 160.0
F_83 = 99194853094755497, Diferença F_83 = 272.0
F_84 = 160500643816367088, Diferença F_84 = 448.0
F_85 = 259695496911122585, Diferença F_85 = 736.0
F_86 = 420196140727489673, Diferença F_86 = 1216.0
F_87 = 679891637638612258, Diferença F_87 = 2048.0
F_88 = 1100087778366101931, Diferença F_88 = 3200.0
F_89 = 1779979416004714189, Diferença F_89 = 5120.0
F_90 = 2880067194370816120, Diferença F_90 = 8192.0
F_91 = 4660046610375530309, Diferença F_91 = 14336.0
F_92 = 7540113804746346429, Diferença F_92 = 22528.0
F_93 = -6246583658587674878, Diferença F_93 = 1.844674407370959e19
</code></pre>
<p>Impressionantemente, esse erro não é tão pequeno assim. Ele cresce com o tamanho de <code>n</code>, de modo que essa aproximação é inviável para valores grandes de <code>n</code>.</p>
<p>A fórmula para o n-ésimo número de Fibonacci é</p>
\[ F_n = \frac{\phi^n - \psi^n}{\sqrt{5}}. \]
<p>Acontece que \(\phi > 1\) e \(0 < \psi < 1\), então a distância entre \(\phi^n\) e \(\psi^n\) cresce bastante com \(n\). Além disso, ambos são irracionais, então seus valores já são aproximados. Neste caso, é mais simples calcular os números de Fibonacci utilizando <code>for</code> ou <code>while</code> com inteiros. Claro que isso também vai depender do motivo para se calcular esses números.</p>
<h1 id="aproximações_de_séries"><a href="#aproximações_de_séries" class=header-anchor >Aproximações de Séries</a></h1>
<p>Vamos para um assunto levemente diferente. Uma série é uma soma de infinitos termos numa ordem dada.</p>
\[ S = \sum_{k = 1}^{\infty} a_k. \]
<p>A questão aqui é, em geral, se essa soma existe ou não. Para tanto, define-se uma sequência \((s_1,s_2,\dots,s_n,\dots)\) dada por</p>
\[ s_n = \sum_{k = 1}^n a_k. \]
<p>Se essa sequência convergence, então essa série converge.</p>
<p>Computacionalmente, em geral, estamos mais preocupados em calcular essa soma. Um resultado básico de série diz que para que a série convirja, é necessário que \(a_k \rightarrow 0\). Como já vimos, isso irá nos causar alguns problemas, dado que</p>
\[ s_{n+1} = s_n + a_{n+1}, \]
<p>e \(a_{n+1}\) vai eventualmente ser muito pequeno.</p>
<p>Matematicamente, muitas vezes temos um objetivo, como calcular \(\pi\), que pode ser obtido pelo cálculo de uma série. Devemos nos preocupar em como fazer isso de uma maneira computacional eficiente que não perca muita precisão. Frequentemente, teremos limites computacionais para essa eficiência, e aí devemos voltar à matemática para conseguir alguma maneira melhor de resolver o problema inicial.</p>
<h2 id="expansão_de_taylor"><a href="#expansão_de_taylor" class=header-anchor >Expansão de Taylor</a></h2>
<p>Como deve ter sido visto no curso de Cálculo, uma função continuamente diferenciável até ordem \(n\) admite uma aproximação polinomial em torno de um ponto \(a\) de seu domínio dada por</p>
\[ P_n(x) = f(a) + f'(a)(x-a) + \frac{1}{2}f''(a)(x-a)^2 + \frac{1}{3!}f'''(a)(x-a)^3 + \dots + \frac{1}{n!}f^{(n)}(a)(x-a)^n. \]
<p>Esse polinômio é chamado polinômio de Taylor de ordem \(n\) em torno do ponto \(a\), e existem alguns teoremas indicando o quão boa é essa aproximação.</p>
<p><strong>Teorema:</strong> Se \(f\) é continuamente diferenciável até ordem \(n\) no ponto \(a\), então</p>
\[ f(x) = P_n(x) + r_n(x), \]
<p>onde</p>
\[ \lim_{x \rightarrow a} \frac{ r_n(x) }{ |x - a|^n } = 0. \]
<p><strong>Teorema:</strong> Se \(f\) é continuamente diferenciável até ordem \(n+1\) no intervalo fechado de \(a\) à \(x\), então</p>
\[ f(x) = P_n(x) + \int_a^x \frac{f^{(n+1)}(t)}{n!}(x-t)^n \text{d} t. \]
<p><strong>Teorema:</strong> Se \(f\) é continuamente diferenciável até ordem \(n+1\) num intervalo aberto contento \(a\) e \(f^{(n)}\) é contínua no intervalo fechado de \(a\) à \(x\), então</p>
\[ f(x) = P_n(x) + \frac{1}{(n+1)!} f^{(n+1)}(\xi)(x - a)^{n + 1}, \]
<p>onde \(\xi\) é um número real entre \(a\) e \(x\).</p>
<p>Podemos usar o conceito da expansão de Taylor para calcular numericamente alguns valores de funções não polinomiais. O caso mais comum é o da função \(\exp(x) = e^x\), onde \(e\) é o número de Euler.</p>
<pre><code class=language-julia >MathConstants.e</code></pre><pre><code class=plaintext >ℯ = 2.7182818284590...</code></pre>
<p><em>Aviso: A função exponencial já costuma estar implementada em baixo nível, no entanto faremos este estudo por questões didáticas.</em></p>
<p>A função \(e^x\) tem a seguinte expansão de Taylor em torno do ponto \(0\).</p>
\[ e^x = 1 + x + \frac{x^2}{2} + \frac{x^3}{3!} + \frac{x^4}{4!} + \dots + \frac{x^n}{n!} + \dots. \]
<p>Então é bastante simples definir um algoritmo que calcule a aproximação da exponecial dado \(x\) e \(n\).</p>
<p>Entrada: x e n ≧ 0</p>
<ol>
<li><p>Inicialização: \(E \leftarrow 1.0\)</p>

<li><p>Para k de 1 à n</p>
<ol>
<li><p>\(E \leftarrow E + x^k/k!\)</p>

</ol>

<li><p>Retorne E  Saída: E ≈ eˣ com n termos da expansão de Taylor</p>

</ol>
<pre><code class=language-julia >E &#61; 1.0
E &#43;&#61; 1.0   # k &#61; 1
E &#43;&#61; 0.5   # k &#61; 2
E &#43;&#61; 1/6   # k &#61; 3
E &#43;&#61; 1/24  # k &#61; 4
E &#43;&#61; 1/120 # k &#61; 5</code></pre><pre><code class=plaintext >2.7166666666666663</code></pre>
<pre><code class=language-julia >MathConstants.e - E</code></pre><pre><code class=plaintext >0.0016151617923787498</code></pre>
<pre><code class=language-julia >function exponencial&#40;x, n&#41;
    #Exercício. Usa a função factorial&#40;n&#41; para calcular n&#33;
    E &#61; 1.0
    for k &#61; 1:n
        E &#43;&#61; x^k / factorial&#40;k&#41;
    end
    return E
end

exponencial&#40;1.0, 20&#41;</code></pre><pre><code class=plaintext >2.7182818284590455</code></pre>
<pre><code class=language-julia >MathConstants.e - exponencial&#40;1.0, 20&#41;</code></pre><pre><code class=plaintext >-4.440892098500626e-16</code></pre>
<pre><code class=language-julia >abs&#40; exp&#40;2&#41; - exponencial&#40;2.0, 20&#41; &#41; / exp&#40;2&#41;</code></pre><pre><code class=plaintext >6.250497655727703e-15</code></pre>
<pre><code class=language-julia >abs&#40; exp&#40;3&#41; - exponencial&#40;3.0, 20&#41; &#41; / exp&#40;3&#41;</code></pre><pre><code class=plaintext >1.1790767393200277e-11</code></pre>
<pre><code class=language-julia >abs&#40; exp&#40;10&#41; - exponencial&#40;10.0, 20&#41; &#41; / exp&#40;10&#41;</code></pre><pre><code class=plaintext >0.0015882606618580852</code></pre>
<pre><code class=language-julia >abs&#40; exp&#40;3&#41; - exponencial&#40;3.0, 21&#41; &#41; / exp&#40;3&#41;</code></pre><pre><code class=plaintext >OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead
</code></pre>
<p>Vamos testar nossa função contra <code>exp</code>, calculando o erro dessa aproximação. No entanto, note que a função exponencial cresce rapidamente, e como vimos, a precisão de um valor é relativo ao valor. Sendo assim, vamos utilizar o <strong>erro relativo</strong> na nossa comparação.</p>
<p><strong>Definição:</strong> O erro cometido ao se aproximar \(x\) por \(x'\) é \(x - x'\).</p>
<p><strong>Definição:</strong> O <strong>erro absoluto</strong> cometido ao se aproximar \(x\) por \(x'\) é \(|x - x'|\).</p>
<p><strong>Definição:</strong> O <strong>erro relativo</strong> cometido ao se aproximar \(x\) por \(x'\) é \(\dfrac{|x - x'|}{|x|}\).</p>
<pre><code class=language-julia >using Plots
gr&#40;size&#61;&#40;400,300&#41;&#41;

N &#61; collect&#40;1:20&#41;
Erro &#61; &#91;abs&#40;exponencial&#40;1.0, n&#41; - exp&#40;1.0&#41;&#41;/exp&#40;1.0&#41; for n in N&#93;
scatter&#40;N, Erro, yaxis&#61;:log&#41;</code></pre>

  <figure style="text-align: center">
   <img src="/calculo-numerico/assets/calculo-numerico/sequencias-e-series/code/output/plt-exp1.png" alt=""> 
  </figure>
  
<p>Note que após \(n = 17\), o erro é sempre a precisão da máquina. Isso quer dizer que os termos \(a_n\) com \(n > 17\) não afetam a soma, computacionalmente.</p>
<pre><code class=language-julia >N &#61; collect&#40;1:20&#41;
Erro &#61; &#91;abs&#40;exponencial&#40;5.0, n&#41; - exp&#40;5.0&#41;&#41;/exp&#40;5.0&#41; for n in N&#93;
scatter&#40;N, Erro, yaxis&#61;:log&#41;
png&#40;joinpath&#40;@OUTPUT, &quot;plt-exp2&quot;&#41;&#41;</code></pre>

  <figure style="text-align: center">
   <img src="/calculo-numerico/assets/calculo-numerico/sequencias-e-series/code/output/plt-exp2.png" alt=""> 
  </figure>
  
<p>Veja que é erro é muito maior para \(x = 5\) do que para \(x = 1\). Isso acontece porque os termos além de \(n > 20\)  ainda são importantes para a aproximação de \(e^5\). A primeira vista, uma simples solução seria utilizar \(n > 20\), mas veja o que acontece com nossa implementação.</p>
<p>Se você se lembra bem, isso acontece porque para \(21!\) é maior que o máximo dos inteiros de 64 bits. Isso quer dizer que para calcular \(e^x\) corretamente, devemos dar mais atenção aos detalhes do algoritmo. Note também que \(x^n\) pode acabar ficando muito grande para \(x\) e \(n\) grandes e causar overflow também.</p>
<p>Revisitando nossa soma:</p>
\[ s_n = 1 + x + \frac{x^2}{2} + \dots + \frac{x^n}{n!}, \]
<p>de modo que</p>
\[ s_n = s_{n-1} + \frac{x^n}{n!}. \]
<p>O termo à direita da soma não pode ser calculado diretamente pois cada termo da fração pode &quot;explodir&quot; &#40;termo que utilizarei para dizer causar overflow&#41;. No entanto, o resultado da fração é bem comportado, então podemos tentar chegar nesse valor de outra maneira.</p>
<p>Veja que</p>
\[ \frac{x^n}{n!} = \frac{x\times x\times x\times\dots\times x}{1\times2\times3\times\dots\times n}
= \frac{x}{1}\times\frac{x}{2}\times\frac{x}{3}\times\dots\times\frac{x}{n},
\]
<p>então podemos fazer esse cálculo seguindo essa ordem, de maneira que o produto todo ficará equilibrado.</p>
<p>No entanto, é possível deixar esse produto mais eficiente. Note que se chamarmos \(t_n = \dfrac{x^n}{n!}\), então</p>
\[ s_n = s_{n-1} + t_n, \]
<p>e</p>
\[ t_n = t_{n-1}\times\frac{x}{n}. \]
<p>Em outras palavras, a sequência que é somada também pode ser calculada utilizando o termo anterior. Cada iteração fará então apenas um produto, uma divisão, e uma soma.</p>
<p>Gráfico do termo</p>
<pre><code class=language-julia >x &#61; 10.0
n &#61; 60
E &#61; &#91;1.0&#93;
t &#61; 1.0
for k &#61; 1:n
    t &#61; t * x / k
    push&#33;&#40;E, t&#41;
end
scatter&#40;E, yaxis&#61;:log&#41;</code></pre>

  <figure style="text-align: center">
   <img src="/calculo-numerico/assets/calculo-numerico/sequencias-e-series/code/output/plt-exp3.png" alt=""> 
  </figure>
  
<p>Entrada: \(x\) e \(n \geq 0\)</p>
<ol>
<li><p>Inicialização: \(E \leftarrow 1.0, t \leftarrow 1.0\)</p>

<li><p>Para \(k\) de \(1\) à \(n\)</p>
<ol>
<li><p>\(t \leftarrow t * x / k\)</p>

<li><p>\(E \leftarrow E + t\)</p>

</ol>

<li><p>Retorne \(E\)  Saída: \(E \approx e^x\) com n termos da expansão de Taylor</p>

</ol>
<pre><code class=language-julia >function exponencial2&#40;x, n&#41;
    #Implemente
    E &#61; 1.0
    t &#61; 1.0
    for k &#61; 1:n
        t *&#61; x / k
        E &#43;&#61; t
    end
    return E
end

exponencial2&#40;1.0, 20&#41;</code></pre><pre><code class=plaintext >2.7182818284590455</code></pre>
<pre><code class=language-julia >&#40;exponencial2&#40;10.0, 60&#41; - exp&#40;10.0&#41;&#41; / exp&#40;10&#41;</code></pre><pre><code class=plaintext >-1.6516398231937218e-16</code></pre>
<pre><code class=language-julia >using Plots
N &#61; collect&#40;1:50&#41;
Erro &#61; &#91;abs&#40;exponencial2&#40;1.0, n&#41; - exp&#40;1.0&#41;&#41;/exp&#40;1.0&#41; for n in N&#93;
Erro&#91;findall&#40;Erro .&#61;&#61; 0.0&#41;&#93; .&#61; eps&#40;&#41;
scatter&#40;N, abs.&#40;Erro&#41;, yaxis&#61;:log&#41;</code></pre>

  <figure style="text-align: center">
   <img src="/calculo-numerico/assets/calculo-numerico/sequencias-e-series/code/output/plt-exp4.png" alt=""> 
  </figure>
  
<pre><code class=language-julia >N &#61; collect&#40;1:50&#41;
Erro &#61; &#91;abs&#40;exponencial2&#40;10.0, n&#41; - exp&#40;10.0&#41;&#41;/exp&#40;10.0&#41; for n in N&#93;
Erro&#91;findall&#40;Erro .&#61;&#61; 0.0&#41;&#93; .&#61; eps&#40;&#41;
scatter&#40;N, Erro, yaxis&#61;:log&#41;
ylims&#33;&#40;eps&#40;&#41;/2, 1.0&#41;</code></pre>

  <figure style="text-align: center">
   <img src="/calculo-numerico/assets/calculo-numerico/sequencias-e-series/code/output/plt-exp5.png" alt=""> 
  </figure>
  
<p>Perceba agora que a função <code>exp</code> não recebe um \(n\) específico. A quantidade de termos calculados é específico para o valor \(x\). Para \(x = 0\), \(n = 0\) basta, para \(x = 1\), \(n = 17\) basta, para \(x = 10\), \(n = 45\) foi necessário.</p>
<p>Em particular, como estamos fazendo uma atualização do tipo \(s_n = s_{n-1} + t_n\) e \(t_n\) tende a 0, podemos verificar se obtivemos um erro de arredondamento na soma, de modo que os termos seguintes também não acrescentarão nada.</p>
<p>Entrada: \(x\)</p>
<ol>
<li><p>Inicialização: \(E \leftarrow 1.0, t \leftarrow x, k \leftarrow 1\)</p>

<li><p>Enquanto \(E + t \neq E\)</p>
<ol>
<li><p>\(E \leftarrow E + t\)</p>

<li><p>Incremente \(k\)</p>

<li><p>\(t \leftarrow t * x / k\)</p>

</ol>

<li><p>Retorne \(E\)  Saída: \(E \approx e^x\)</p>

</ol>
<pre><code class=language-julia >function exponencial3&#40;x&#41;
    #Implemente
    E &#61; 1.0
    t &#61; x
    k &#61; 1
    while E &#43; t &#33;&#61; E
        E &#43;&#61; t
        k &#43;&#61; 1
        t *&#61; x / k
    end
    return E
end

plot&#40;x-&gt;exp&#40;x&#41; - exponencial3&#40;x&#41;, 0, 10.0&#41;</code></pre>

  <figure style="text-align: center">
   <img src="/calculo-numerico/assets/calculo-numerico/sequencias-e-series/code/output/plt-exp6.png" alt=""> 
  </figure>
  
<pre><code class=language-julia >plot&#40;x-&gt;abs&#40;exp&#40;x&#41; - exponencial3&#40;x&#41;&#41;/exp&#40;x&#41;, 0, 10.0&#41;</code></pre>

  <figure style="text-align: center">
   <img src="/calculo-numerico/assets/calculo-numerico/sequencias-e-series/code/output/plt-exp7.png" alt=""> 
  </figure>
  
<p>Por fim, vejamos o que acontece com \(x < 0\).</p>
<pre><code class=language-julia >plot&#40;x-&gt;abs&#40;exp&#40;x&#41; - exponencial3&#40;x&#41;&#41;/exp&#40;x&#41;, -10.0, 10.0&#41;</code></pre>

  <figure style="text-align: center">
   <img src="/calculo-numerico/assets/calculo-numerico/sequencias-e-series/code/output/plt-exp7.png" alt=""> 
  </figure>
  
<p>O erro cresce novamente. Isso acontece porque o termo \(t_n\) fica alternando de sinal, e fica pequeno antes de contribuir o suficiente para fazer a diferença necessária. Uma maneira de remediar esse problema é usar a relação \(e^x = \dfrac{1}{e^{-x}}\).</p>
<pre><code class=language-julia >function exponencial4&#40;x&#41;
    if x &lt; 0
        return 1.0/exponencial4&#40;-x&#41;
    end
    #Implemente
    return exponencial3&#40;x&#41;
end

plot&#40;x-&gt;abs&#40;exp&#40;x&#41; - exponencial4&#40;x&#41;&#41;/exp&#40;x&#41;, -10.0, 10.0&#41;</code></pre>

  <figure style="text-align: center">
   <img src="/calculo-numerico/assets/calculo-numerico/sequencias-e-series/code/output/plt-exp8.png" alt=""> 
  </figure>
  
<h2 id="cálculo_de_pi"><a href="#cálculo_de_pi" class=header-anchor >Cálculo de \(\pi\)</a></h2>
<p>Um tópico bastante interessante de computação matemática é o cálculo do valor de \(\pi\). O interesse no cálculo de \(\pi\) é antigo, e existem várias maneiras de fazê-lo. Além disso, a busca pelo valor de \(\pi\) com a maior quantidade de dígitos corretos é uma disputa matemática bastante acirrada.</p>
<p>Das maneiras de calcular \(\pi\), uma das mais interessantes, em minha opinião, é através da identidade</p>
\[ \arctan 1 = \frac{\pi}{4} \qquad \Rightarrow \qquad \pi = 4 \arctan 1. \]
<p>Agora, utilizamos a derivada de \(\arctan\):</p>
\[ \frac{\text{d}}{\text{d}x}\arctan x = \frac{1}{1+x^2}, \]
<p>e a expansão da fração para \(|x| < 1\):</p>
\[ \frac{1}{1+x^2} = 1 - x^2 + x^4 - x^6 + \dots + (-1)^n x^{2n} + \dots. \]
<p>Integrando, temos</p>
\[ \arctan x = x - \frac{x^3}{3} + \frac{x^5}{5} - \frac{x^7}{7} + \dots + (-1)^n\frac{x^{2n+1}}{2n+1} +
\dots\]
<p>É possível mostrar que essa série converge para \(x = 1\) também, de modo que</p>
\[ \frac{\pi}{4} = \arctan 1 = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \dots \frac{(-1)^n}{2n+1} + \dots. \]
<p>Utilizando conceitos parecidos com o da expansão da exponencial, podemos calcular \(\pi\) sem precisar passar um valor de \(n\), <strong>porém</strong>, essa convergência é muito lenta. No exemplo abaixo, colocaremos uma condição de parada para \(n > 1.000.000.000\).</p>
<pre><code class=language-julia >function pi_atan&#40;&#41;
    S &#61; 1.0
    n &#61; 1
    σ &#61; -1
    t &#61; σ/&#40;2n&#43;1&#41;
    while S &#43; t &#33;&#61; S
        S &#43;&#61; t
        σ &#61; -σ
        n &#43;&#61; 1
        t &#61; σ/&#40;2n&#43;1&#41;
        if n &gt; 1_000_000_000
            break
        end
    end
    return 4S
end

pi_atan&#40;&#41;</code></pre><pre><code class=plaintext >3.1415926545880506</code></pre>
<pre><code class=language-julia >@time pi_atan&#40;&#41; - pi</code></pre><pre><code class=plaintext >  2.107942 seconds
9.982574766809194e-10</code></pre>
<p>O valor é, de fato, calculado até uma aproximação razoável, mas demora muito e leva muitas iterações. Por sorte, existem dezenas de outras maneiras de se calcular \(\pi\).</p>
<p>Uma dessas maneiras é a série</p>
\[ \pi = \sqrt{12}\bigg(1 - \frac{1}{3\times 3} + \frac{1}{5\times 3^2} - \frac{1}{7\times 3^3} + \frac{1}{9\times 3^4} - \dots\bigg) = \sqrt{12}\sum_{k=0}^{\infty}\frac{(-1)^k}{(2k+1)3^k}. \]
<pre><code class=language-julia >function pi_madhava&#40;&#41;
    S &#61; 1.0
    third &#61; 1.0/3.0
    σ &#61; -1
    pow_third &#61; third
    t &#61; σ * third * third
    n &#61; 1
    while S &#43; t &#33;&#61; S
        S &#43;&#61; t
        n &#43;&#61; 1
        pow_third *&#61; third
        σ &#61; -σ
        t &#61; σ * pow_third / &#40;2n &#43; 1&#41;
    end
    println&#40;&quot;n &#61; &#36;n&quot;&#41; # Usar para mostrar quantas iterações
    return sqrt&#40;12&#41; * S
end

pi_madhava&#40;&#41; - pi</code></pre><pre><code class=plaintext >n = 31
8.881784197001252e-16</code></pre>
<p>Note que com 31 iterações já chegamos num valor de \(\pi\) decente.</p>
<h3 id=pi_com_bigfloat ><a href="#pi_com_bigfloat" class=header-anchor >\(\pi\) com BigFloat</a></h3>
<p>Como dito anteriormente, existe uma busca por \(\pi\) com diversas casas decimais corretas. Você já deve ter percebido que o Julia traz uma implementação própria de \(\pi\), chamada através de <code>pi</code>. Essa aproximação pode ser vista com <code>BigFloat</code> também.</p>
<pre><code class=language-julia >BigFloat&#40;pi&#41;</code></pre><pre><code class=plaintext >3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275900994657640789512694683983525957098258226205224894077267194782684826014769909026401363944374553050682034962524517493996514314298091906592509372216964615157098583874105978859597729754989301617539284681382686838689427741559918559252459539594310499725246808459872736446958486538367362226260991246080512438843904512441365497627807977156914359977001296160894416948685558484063534220722258284886481584560285060168427394522674676788952521385225499546667278239864565961163548862305774564980355936345681743241125150760694794510965960940252288797108931456691368672287489405601015033086179286809208747609178249385890097149096759852613655497818931297848216829989487226588048575640142704775551323796414515237462343645428584447952658678210511413547357395231134271661021359695362314429524849371871101457654035902799344037420073105785390621983874478084784896833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080951465502252316038819301420937621378559566389377870830390697920773467221825625996615014215030680384477345492026054146659252014974428507325186660021324340881907104863317346496514539057962685610055081066587969981635747363840525714591028970641401109712062804390397595156771577004203378699360072305587631763594218731251471205329281918261861258673215791984148488291644706095752706957220917567116722910981690915280173506712748583222871835209353965725121083579151369882091444210067510334671103141267111369908658516398315019701651511685171437657618351556508849099898599823873455283316355076479185358932261854896321329330898570642046752590709154814165498594616371802709819943099244889575712828905923233260972997120844335732654893823911932597463667305836041428138830320382490375898524374417029132765618093773444030707469211201913020330380197621101100449293215160842444859637669838952286847831235526582131449576857262433441893039686426243410773226978028073189154411010446823252716201052652272111660396665573092547110557853763466820653109896526918620564769312570586356620185581007293606598764861179104533488503461136576867532494416680396265797877185560845529654126654085306143444318586769751456614068007002378776591344017127494704205622305389945613140711270004078547332699390814546646458807972708266830634328587856983052358089330657574067954571637752542021149557615814002501262285941302164715509792592309907965473761255176567513575178296664547791745011299614890304639947132962107340437518957359614589019389713111790429782856475032031986915140287080859904801094121472213179476477726224142548545403321571853061422881375850430633217518297986622371721591607716692547487389866549494501146540628433663937900397692656721463853067360965712091807638327166416274888800786925602902284721040317211860820419000422966171196377921337575114959501566049631862947265473642523081770367515906735023507283540567040386743513622224771589150495309844489333096340878076932599397805419341447377441842631298608099888687413260472156951623965864573021631598193195167353812974167729478672422924654366800980676928238280689964004824354037014163149658979409243237896907069779422362508221688957383798623001593776471651228935786015881617557829735233446042815126272037343146531977774160319906655418763979293344195215413418994854447345673831624993419131814809277771038638773431772075456545322077709212019051660962804909263601975988281613323166636528619326686336062735676303544776280350450777235547105859548702790814356240145171806246436267945612753181340783303362542327839449753824372058353114771199260638133467768796959703098339130771098704085913374641442822772634659470474587847787201927715280731767907707157213444730605700733492436931138350493163128404251219256517980694113528013147013047816437885185290928545201165839341965621349143415956258658655705526904965209858033850722426482939728584783163057777560688876446248246857926039535277348030480290058760758251047470916439613626760449256274204208320856611906254543372131535958450687724602901618766795240616342522577195429162991930645537799140373404328752628889639958794757291746426357455254079091451357111369410911939325191076020825202618798531887705842972591677813149699009019211697173727847684726860849003377024242916513005005168323364350389517029893922334517220138128069650117844087451960121228599371623130171144484640903890644954440061986907548516026327505298349187407866808818338510228334508504860825039302133219715518430635455007668282949304137765527939751754613953984683393638304746119966538581538420568533862186725233402830871123282789212507712629463229563989898935821167456270102183564622013496715188190973038119800497340723961036854066431939509790190699639552453005450580685501956730229219139339185680344903982059551002263535361920419947455385938102343955449597783779023742161727111723643435439478221818528624085140066604433258885698670543154706965747458550332323342107301545940516553790686627333799585115625784322988273723198987571415957811196358330059408730681216028764962867446047746491599505497374256269010490377819868359381465741268049256487985561453723478673303904688383436346553794986419270563872931748723320837601123029911367938627089438799362016295154133714248928307220126901475466847653576164773794675200490757155527819653621323926406160136358155907422020203187277605277219005561484255518792530343513984425322341576233610642506390497500865627109535919465897514131034822769306247435363256916078154781811528436679570611086153315044521274739245449454236828860613408414863776700961207151249140430272538607648236341433462351897576645216413767969031495019108575984423919862916421939949072362346468441173940326591840443780513338945257423995082965912285085558215725031071257012668302402929525220118726767562204154205161841634847565169998116141010029960783869092916030288400269104140792886215078424516709087000699282120660418371806535567252532567532861291042487761825829765157959847035622262934860034158722980534989650226291748788202734209222245339856264766914905562842503912757710284027998066365825488926488025456610172967026640765590429099456815065265305371829412703369313785178609040708667114965583434347693385781711386455873678123014587687126603489139095620099393610310291616152881384379099042317473363948045759314931405297634757481193567091101377517210080315590248530906692037671922033229094334676851422144773793937517034436619910403375111735471918550464490263655128162288244625759163330391072253837421821408835086573917715096828874782656995995744906617583441375223970968340800535598491754173818839994469748676265516582765848358845314277568790029095170283529716344562129640435231176006651012412006597558512761785838292041974844236080071930457618932349229279650198751872127267507981255470958904556357921221033346697499235630254947802490114195212382815309114079073860251522742995818072471625916685451333123948049470791191532673430282441860414263639548000448002670496248201792896476697583183271314251702969234889627668440323260927524960357996469256504936818360900323809293459588970695365349406034021665443755890045632882250545255640564482465151875471196218443965825337543885690941130315095261793780029741207665147939425902989695946995565761218656196733786236256125216320862869222103274889218654364802296780705765615144632046927906821207388377814233562823608963208068222468012248261177185896381409183903673672220888321513755600372798394004152970028783076670944474560134556417254370906979396122571429894671543578468788614445812314593571984922528471605049221242470141214780573455105008019086996033027634787081081754501193071412233908663938339529425786905076431006383519834389341596131854347546495569781038293097164651438407007073604112373599843452251610507027056235266012764848308407611830130527932054274628654036036745328651057065874882256981579367897669742205750596834408697350201410206723585020072452256326513410559240190274216248439140371</code></pre>
<p>Podemos modificar nossa implementação para buscar \(\pi\) com <code>BigFloat</code> também.</p>
<pre><code class=language-julia >function pi_madhava_BF&#40;&#41;
    S &#61; BigFloat&#40;1.0&#41;
    third &#61; BigFloat&#40;1.0&#41;/BigFloat&#40;3.0&#41;
    σ &#61; -1
    pow_third &#61; third
    t &#61; σ * third * third
    n &#61; 1
    while S &#43; t &#33;&#61; S
        S &#43;&#61; t
        n &#43;&#61; 1
        pow_third *&#61; third
        σ &#61; -σ
        t &#61; σ * pow_third / &#40;2n &#43; 1&#41;
        if n &gt; 1_000_000
            break
        end
    end
    println&#40;&quot;n &#61; &#36;n&quot;&#41; # Usar para mostrar quantas iterações
    return sqrt&#40;BigFloat&#40;12.0&#41;&#41; * S
end

setprecision&#40;2^10&#41;
pi_madhava_BF&#40;&#41; - pi</code></pre><pre><code class=plaintext >n = 641
0.0</code></pre>
<pre><code class=language-julia >setprecision&#40;2^11&#41;
round&#40;Int, -log10&#40;eps&#40;BigFloat&#41;&#41;&#41;</code></pre><pre><code class=plaintext >616</code></pre>
<pre><code class=language-julia >for n &#61; 10:14
    setprecision&#40;2^n&#41;

    E &#61; max&#40;abs&#40;pi_madhava_BF&#40;&#41; - BigFloat&#40;pi&#41;&#41;, eps&#40;BigFloat&#41;&#41;
    casas &#61; round&#40;Int, -log10&#40;E&#41;&#41;
    println&#40;&quot;Com &#36;&#40;2^n&#41; bits obtive &#36;casas casas&quot;&#41;
end</code></pre><pre><code class=plaintext >n = 641
Com 1024 bits obtive 308 casas
n = 1286
Com 2048 bits obtive 616 casas
n = 2578
Com 4096 bits obtive 1231 casas
n = 5161
Com 8192 bits obtive 2465 casas
n = 10329
Com 16384 bits obtive 4930 casas
</code></pre>
<pre><code class=language-julia >setprecision&#40;2^15&#41;
@time pi_madhava_BF&#40;&#41;;</code></pre><pre><code class=plaintext >n = 20666
  1.328119 seconds (206.68 k allocations: 420.997 MiB, 2.74% gc time)
</code></pre>
<pre><code class=language-julia >function logaritmo2&#40;&#41;
    ln2 &#61; 1.0 / 2.0
    k &#61; 2
    r &#61; 1 / 4
    while ln2 &#43; r /k &#33;&#61; ln2
        ln2 &#43;&#61; r / k
        k &#43;&#61; 1
        r &#61; r / 2
        if k &gt; 1_000_000
            break
        end
    end
    println&#40;&quot;k &#61; &#36;k&quot;&#41;
    return ln2
end

logaritmo2&#40;&#41; - log&#40;2&#41;</code></pre><pre><code class=plaintext >k = 49
-2.220446049250313e-16</code></pre>
<h1 id="exercícios"><a href="#exercícios" class=header-anchor >Exercícios</a></h1>
<p>Faça os exercícios do capítulo 1 do livro Cálculo Numérico de Ruggiero e Lopes.</p>
<ol>
<li><p>Calcule a expansão de Taylor das seguintes funções, em torno do ponto a dado:</p>

</ol>
<ul>
<li><p>\(f(x) = x^2 - 5x + 6\), \(a = 2\);</p>

<li><p>\(g(x) = x^3 - 3x^2 + 3x - 1\), \(a = 1\);</p>

<li><p>\(h(x) = e^x\), \(a = 0\);</p>

<li><p>\(z(x) = \ln (x)\), \(a = 1\);</p>

</ul>
<ol start=5 >
<li><p>Considere as seguintes séries e sequências convergentes:</p>

</ol>
<ul>
<li><p>\(2 = 1 + \frac{1}{2} + \frac{1}{4} + \frac{1}{8} + \dots + \frac{1}{2^n} + \dots\).</p>

<li><p>\(a_{n+1} = \frac{a_n}{2} + \frac{1}{a_n}\), com \(a_1 = 1\).</p>

<li><p>\(b_{n+1} = \sqrt{b_n + 1}\), com \(b_1 = 1\).</p>

<li><p>\(\phi_n = \dfrac{F_n}{F_{n-1}}\), onde \(F_n\) é o n-ésimo termo de Fibonacci.</p>

<li><p>Alguma série para \(\pi\) da internet.</p>

</ul>
<p>Para cada uma delas, faça os seguintes itens</p>
<ul>
<li><p>Implemente uma função que recebe um número \(n\) e calcula a soma parcial \(s_n\) se o item for uma série, ou n-ésimo elemento se o item for uma sequência. Faça sua função ser o mais econômica possível e evite overflows.</p>

<li><p>Faça um gráfico do erro pelo número de termos \(n\).</p>

<li><p>Dado \(\varepsilon > 0\), é possível determinar n de modo que o erro seja menor que \(\varepsilon\)? Veja quantos casos você consegue fazer isso, ou encontrar algum limitante desse tipo.</p>

</ul>

</div>
</div>
</div>

<footer>
<div class="container-fluid text-center social-footer">
    <a href="mailto:abel.s.siqueira@gmail.com">
        <i class="fas fa-2x fa-envelope" aria-hidden=true ></i>
    </a><a href="https://github.com/abelsiqueira">
        <i class="fab fa-2x fa-github-square" aria-hidden=true ></i>
    </a><a href="https://linkedin.com/in/abel-siqueira/">
        <i class="fab fa-2x fa-linkedin" aria-hidden=true ></i>
    </a><a href="https://twitter.com/abel_siqueira">
        <i class="fab fa-2x fa-twitter-square" aria-hidden=true ></i>
    </a><a href="https://www.researchgate.net/profile/Abel_Siqueira">
        <i class="fab fa-2x fa-researchgate" aria-hidden=true ></i>
    </a><a href="http://orcid.org/0000-0003-4451-281X">
        <i class="fab fa-2x fa-orcid" aria-hidden=true ></i>
    </a>
</div>
</footer>


<script src="/calculo-numerico/libs/katex/katex.min.js"></script>
<script src="/calculo-numerico/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>



<script src="/calculo-numerico/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>


<script src="/calculo-numerico/libs/bootstrap.bundle.min.js" crossorigin=anonymous ></script>
<script src="https://kit.fontawesome.com/d17d5e5245.js" crossorigin=anonymous ></script>
<script type="text/javascript" src="https://cdn.rawgit.com/pcooksey/bibtex-js/ef59e62c/src/bibtex_js.js"></script>